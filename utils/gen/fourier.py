import sys

def zeta_radix2(n):
    def rsqrt(a):
        x = 2
        for _ in range(20):
            x = (x + a / x) / 2
        return x

    zetas = [(1.0, 0.0), (-1.0, 0.0), (0.0, 1.0)]

    (x, y) = zetas[-1]
    for _ in range(n - 2):
        a = rsqrt((x + rsqrt(x * x + y * y)) / 2)
        (x, y) = (a, y / a / 2)
        zetas.append((x, y))

    return zetas

def fourier_coeffs(zetas):
    cs = [(1.0, 0.0) for _ in range(2 ** (len(zetas) - 1))]
    for i in range(1, len(zetas)):
        dx = 2 ** (len(zetas) - i - 1)
        (x, y) = zetas[i]
        for j in range(1, 2 ** i, 2):
            cs[j * dx] = (x, y)
            (x, y) = (zetas[i - 1][0] * x - zetas[i - 1][1] * y, zetas[i - 1][0] * y + zetas[i - 1][1] * x)
    return cs

def newton(f, x0, n=20, dx=0.0001):
    x = x0
    for _ in range(n):
        x = x - f(x) / (f(x + dx) - f(x - dx)) * 2 * dx
    return x

def tsin(x):
    xm = x**2
    r = 0
    s = x
    for i in range(100):
        r += s
        s *= xm / (4 * i + 2) / (4 * i + 3)
        r -= s
        s *= xm / (4 * i + 4) / (4 * i + 5)
    return r

pi = newton(tsin, 3.0)
z32 = zeta_radix2(32)
f16 = fourier_coeffs(z32[:17])

def_const_double = lambda n, v: print(f"const double {n}={v.hex()};")

fmt_complex = lambda z: f"__builtin_complex({z[0].hex()},{z[1].hex()})"

def def_const_complex_array(n, vs):
    print(f"const double _Complex {n}[]={{" + ",".join([fmt_complex(v) for v in vs]) + "};")


print(f"/* generated by utils/gen/{sys.argv[0].split('/')[-1]} */")
def_const_double("__pi", pi)
def_const_complex_array("__z32", z32)
def_const_complex_array("__f16", f16)
